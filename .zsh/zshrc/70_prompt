#
# Prompt and terminal title
#
## This is a modified version of the 'gentoo' prompt
## It also has a right prompt that displays alternating time/date, as
## well as the exit code of the previous command if it wasn't 0 and history
## event numbers every 10 items.

## This is also where the terminal/screen title are set.

autoload -U promptinit
promptinit

# Clear xterm title, not really needed but handy for testing the escape codes
# under different terminals.
# echo -ne '\e]0\a'

###
# PROMPT

###
# RPROMPT

# Enabled by default
RPROMPT_ENABLED=1
# Alternate between these expressions and append to the end of RPROMPT
RPROMPT_DATETIME=('%D{%T}' ' %D{%b %d} ')
RPROMPT_DATETIME=("$RPROMPT_DATETIME[1]" "$RPROMPT_DATETIME[@]")
# Color codes appended to the array by using ^ (RC_EXPAND_PARAM)
RPROMPT_DATETIME=(\[%{${fg[yellow]}%}${^RPROMPT_DATETIME}%{${fg[default]}%}\])
# Exit code if != 0
RPROMPT_EXITCODE="%(?..%{${fg[red]}%}(%?%)%{${fg[default]}%} )"
# Path
# this is too damn long!
# RPROMPT_PATH="%{${fg[cyan]}%}%/%{${fg[default]}%} "

function title {
    if [[ $TERM == screen* ]]; then
        # Use these two for GNU Screen:
        print -nR $'\ek'$1$'\e'"\\"
        shift
#       print -nR $'\e]0;'$*$'\a'
        print -nR $'\e_screen \005 | '$*$'\e'"\\"
    elif [[ $TERM == "xterm" || $TERM == rxvt* ]]; then
        # Use this one instead for XTerms:
        shift
        print -nR $'\e]0;'$@$'\a'
    fi
}
  
function precmd {
  title zsh "$PWD"
}
  
###
# precmd()

precmd() {
    ###
    # Terminal and screen title
    local termtitle RPROMPT_HISTEVENT GIT_BRANCH

    ## Changing IFS breaks a few things otherwise, especially clear-zle-screen
    IFS=$' \t\n'

    # termtitle=$(print -P "%(!.-=*[ROOT]*=- | .)%n@%m:%~ | ${COLUMNS}x${LINES} | %y")
    termtitle=$(print -P "%n@%m:%~ | ${COLUMNS}x${LINES} | %y")
    title zsh "$termtitle"
#    print "***********************************************"
 
    ###
    # RPROMPT
    if [[ -n $RPROMPT_ENABLED ]]; then
        # Alternate between these expressions and append to the end of RPROMPT
        for ((i=2; i<= ${#RPROMPT_DATETIME}; i++)); do
            if [[ $RPROMPT_DATETIME[i] == $RPROMPT_DATETIME[1] ]]; then
                if [[ -n $RPROMPT_DATETIME[((i+1))] ]]; then
                    RPROMPT_DATETIME[1]=$RPROMPT_DATETIME[((i+1))]
                else
                    RPROMPT_DATETIME[1]=$RPROMPT_DATETIME[2]
                fi
                break
            fi
        done

        # Display history event number every 10 commands.
        # it got boring after a while../.
        # if (($(print -P ${:-%\!})%10==0)); then
        #     RPROMPT_HISTEVENT="[%{${fg[blue]}%}%!%{${fg[default]}%}] "
        # else
        #     unset RPROMPT_HISTEVENT
        # fi

        if [[ -d .git ]]; then
            GIT_BRANCH="%{${fg[green]}%}{${$(git-symbolic-ref HEAD 2>/dev/null)#refs/heads/}}%{${fg[default]}%} "
        fi

        RPROMPT="${GIT_BRANCH}${RPROMPT_HISTEVENT}${RPROMPT_EXITCODE}${RPROMPT_PATH}${RPROMPT_DATETIME[1]}"
    fi

    ## Show running jobs
    [[ -o interactive && -z $NRJ ]] && jobs -l;
    
}

## Prompt taken from MadCoder's config, apparently stolen from madduck's
## TODO: add other VCSs, incorporate more ideas
[[ -n $functions[madduck] ]] && madduck

###
# preexec()

preexec() {
## Deprecated
    local escape_seq
    escape_seq="("$'\a|\b|\e|\f|\n|\r|\t|\v'"|\\a|\\b|\\c|\\e|\\f|\\n|\\r|\\t|\\v)"
    case "$TERM" in
        screen*)
            ## screen title
            local CMD=${1[(wr)^(*=*|sudo|time|fg|nice|-*)]}
            echo -ne "\ek$CMD\e\\"
            ## Terminal title
            # Reminder: the correct escape sequence inside screen is '\e_$string\e\'
            # When using the traditional '\e$string\a', garbage is printed
            # before the prompt.
            print -Pn "\e_screen \005 | %(!.-=*[ROOT]*=- | .)%n@%m: ${1//${~escape_seq}/·} \e\\"
    ;;
        ^(dumb|linux))
            # Escape sequences *must* be removed, otherwise print will interpret them and they
            # will go to the terminal, not to its titlebar.
            print -Pn "\e]0;%(!.-=*[ROOT]*=- | .)%n@%m: ${1//${~escape_seq}/·}\a"
        ;;
    esac
}

function preexec {
## Deprecated
  emulate -L zsh
  local -a cmd; cmd=(${(z)1})
  title $cmd[1]:t "$cmd[2,-1]"
}

preexec() {
    # With bits from http://zshwiki.org/home/examples/hardstatus
    # emulate -L zsh
    local -a cmd; cmd=(${(z)1})           # Re-parse the command line
    local termtitle

    # Prepend this string to the title.
    # termtitle=$(print -P "%(!.-=*[ROOT]*=- | .)%n@%m:")
    termtitle=$(print -P "%n@%m:")

    case $cmd[1] in
        fg)
            if (( $#cmd == 1 )); then
                # No arguments, must find the current job
                # Old approach: cmd=(builtin jobs -l %+)
                #   weakness: shows a load of bs
                title ${jobtexts[${(k)jobstates[(R)*+*]}]%% *} "$termtitle ${jobtexts[${(k)jobstates[(R)*+*]}]}"
            else
                # Replace the command name, ignore extra args.
                # Old approach: cmd=(builtin jobs -l ${(Q)cmd[2]})
                #     weakness: shows all matching jobs on the title, not just one
                title "${jobtexts[${cmd[2]#%}]%% *}" "$termtitle $jobtexts[${cmd[2]#%}]"
            fi
            ;;
        %*) title "${jobtexts[${cmd[1]#%}]% *}" "$termtitle $jobtexts[${cmd[1]#%}]"
            ;;
        exec|sudo) shift cmd
            # If the command is 'exec', drop that, because
            # we'd rather just see the command that is being
            # exec'd. Note the ;& to fall through the next entry.
            ;& 
        *=*) shift cmd;&
        *)  title $cmd[1]:t "$termtitle $cmd[*]"    # Starting a new job.
            ;;
        esac
}

###
# Catch SIGWINCH to re-print COLSxLINES
trap precmd 28

# vim:ft=zsh
